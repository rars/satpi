
#include "RandomKSatFormula.hpp"
#include "BooleanVariable.hpp"
#include "Clause.hpp"
#include "Literal.hpp"
#include "Utility.hpp"

#include <random>
#include <iostream>
#include <cstdlib>
#include <sstream>
#include <fstream>

namespace satpi
{
    RandomKSatFormula::RandomKSatFormula(
        const std::uint32_t numberOfVariables,
        const std::uint32_t clauseSize,
        const double alpha)
        : m_variables(), m_clauses()
    {
        GenerateRandomKSat(numberOfVariables, clauseSize, alpha);
    }

    RandomKSatFormula::~RandomKSatFormula()
    {}

    void RandomKSatFormula::GenerateRandomKSat(
        const std::uint32_t numberOfVariables,
        const std::uint32_t clauseSize,
        const double alpha)
    {
        std::string seedValue("Hello");
        std::seed_seq seedSeq(seedValue.begin(), seedValue.end());
        std::mt19937_64 randGen(seedSeq);
        std::uniform_int_distribution<std::uint32_t> variableDistribution(0, numberOfVariables - 1);
        std::uniform_int_distribution<std::uint32_t> zeroOneDistribution(0, 1);

        m_variables.reserve(numberOfVariables);

        for (std::uint32_t variableId = 0; variableId < numberOfVariables; variableId++)
        {
            m_variables.push_back(
                std::shared_ptr<BooleanVariable>(
                    new BooleanVariable(variableId)));
        }

        const std::uint32_t numberOfClauses = static_cast<std::uint32_t>(std::ceil(alpha * static_cast<double>(numberOfVariables)));

        m_clauses.reserve(numberOfClauses);

        for (std::uint32_t clauseId = 0; clauseId < numberOfClauses; clauseId++)
        {
            std::vector<Clause::LiteralPtr> literals;

            std::vector<std::shared_ptr<BooleanVariable>> variablesInClause
                = ChooseNElements(clauseSize, m_variables, randGen);

            for (std::shared_ptr<BooleanVariable> variable : variablesInClause)
            {
                bool isLiteralNegated = zeroOneDistribution(randGen) == 0;

                literals.push_back(
                    std::shared_ptr<Literal>(
                        new Literal(isLiteralNegated, variable)));
            }

            m_clauses.push_back(
                std::shared_ptr<Clause>(new Clause(clauseId, std::move(literals))));
        }

        std::cout
            << "Created " << m_variables.size() << " variables." << std::endl
            << "Created " << m_clauses.size() << " clauses." << std::endl;
    }

    void RandomKSatFormula::Save(const std::string& filepath) const
    {
        std::ofstream ofs(filepath, std::ofstream::out);
        
        std::cout << "Saving to " << filepath << "..." << std::endl;

        ofs << "c Generated by SatPi" << std::endl;
        ofs << "p cnf " << m_variables.size() << " " << m_clauses.size() << std::endl;
        for (const std::shared_ptr<Clause>& clause : m_clauses)
        {
            const std::vector<std::shared_ptr<Literal>>& literals = clause->GetLiterals();

            std::stringstream ss;
            for (const std::shared_ptr<Literal>& literal : literals)
            {
                if (literal->IsNegated())
                {
                    ss << "-";
                }
                ss << literal->GetVariable()->GetId() + 1;
                ss << " ";
            }
            ofs << ss.str() << "0" << std::endl;
        }

        ofs.close();
        std::cout << "Save complete" << std::endl;
    }

    const std::vector<std::shared_ptr<Clause>>& RandomKSatFormula::GetClauses() const
    {
        return m_clauses;
    }

    const std::vector<std::shared_ptr<BooleanVariable>>& RandomKSatFormula::GetVariables() const
    {
        return m_variables;
    }
}
